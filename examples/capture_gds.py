"Captures the signal acquired on the GDS and converts to analytic. The capture is then frequency filtered and the absolute is taken to calculate the $V_{amp}$. The final plot that is generated plots the filtered analytic data with the absolute value and the caluclated $V_{amp}$ (in mV). The voltage ratio (the input_Vamp variable/ calculated $v_{amp}$ is also printed as well as the dB value. This script is serves two purposes in calibrating test signal generated by the AFG. 1. Calculating the raw output of the AFG (no attenuator assemblies). For this step the input_Vamp needs to equal the expected_Vamp since there is no attenuation present and we assume the coaxial cable between the AFG and GDS is lossless. After averaging the calculated $V_{amp}$, the user should edit the input_Vamp to be equal to this calculated value if calibrating the attenuator assemblies as well. 2. Calibrating the attenuator assembly by placing the attenuator assemblies between the AFG output and the GDS. Prior to running the script the user needs to make sure that the input_Vamp is equal to the value in step 1, and that the expected_Vamp reflects the expected $V_{amp}$ when the attenuator assemblies are in place. The caluclated voltage ratio and dB is printed on the final generated plot."
from Instruments import GDS_scope
from pyspecdata import figlist_var
from pylab import text, gca
import numpy as np

expected_Vamp = 500e-3
input_Vamp = 500e-3  # needed for calculating the voltage ratio
filter_width = 10e6  # 10 MHz filter about the average
#                      frequency
with figlist_var() as fl:
    with GDS_scope() as g:
        g.reset()
        # {{{ display settings - use channel 2
        g.CH2.disp = True
        #g.write(":CHAN1:DISP OFF")
        #g.write(":CHAN2:DISP ON")
        #g.write(":CHAN3:DISP OFF")
        #g.write(":CHAN4:DISP OFF")
        # }}}
        # {{{ voltage scale and acquisition settings
        g.CH2.voltscal = (
            expected_Vamp * 1.1 / 4
        )  # set to a little more than $\frac{V_{amp}}{4}$
        g.timscal(10e-9, pos=0)
        g.write(":TIM:MOD WIND")
        g.write(":CHAN2:IMP 5.0E+1")  # set impedance to 50 ohms
        g.write(":TRIG:SOUR CH2")  # set the source of the trigger to channel 2
        g.write(":TRIG:MOD AUTO")  # set trigger to auto
        g.write(":ACQ:MOD HIR")  # high vertical res.
        # }}}
        # {{{ set horizontal cursors on oscilloscope display
        g.write(":CURS:MOD HV")  # set horizontal cursors
        g.write(":CURS:SOUR CH2")  # cursors pertain to channel 2
        # }}}
        # {{{ use expected amplitude to set initial
        #     position of cursors
        g.write(":CURS:V1P " + ("%0.2e" % expected_Vamp).replace("e", "E"))
        g.write(":CURS:V2P " + ("%0.2e" % -expected_Vamp).replace("e", "E"))
        # }}}
        # {{{ grab waveform from oscilloscope
        g.write(":SING")  # capture single acquisition
        data = g.waveform(ch=2)
        data.set_units("t", "s")
        # }}}
    fl.next("Signal captured on GDS oscilloscope")
    fl.plot(data, label="raw signal")
    # {{{ convert to analytic signal
    data.ft("t", shift=True)
    data = data["t":(0, None)]
    data *= 2
    data["t", 0] *= 0.5
    data.ift("t")
    # }}}
    fl.plot(abs(data), label="analytic signal")
    # calculate average frequency of signal
    frq = data.C.phdiff("t", return_error=False).mean("t").item()
    # {{{ now, filter the signal
    data.ft("t")
    data["t" : (0, frq - filter_width / 2)] = 0
    data["t" : (frq + filter_width / 2, None)] = 0
    data.ift("t")
    # }}}
    fl.plot(data, label="filtered analytic signal")
    fl.plot(abs(data), label="abs(filtered analytic signal)")
    Vamp = abs(data["t":(1e-6, 4e-6)]).mean("t").real.item()
    text(
        0.5,
        0.02,
        s=(
            r"$V_{amp} = %0.6f$ mV, voltage ratio = %0.8g, dB = %0.6f dB"
            %(Vamp / 1e-3, input_Vamp / Vamp, 20 * np.log10(input_Vamp / Vamp))
        ),
        transform=gca().transAxes,
    )
